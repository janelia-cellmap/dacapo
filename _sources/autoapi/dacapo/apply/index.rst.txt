:py:mod:`dacapo.apply`
======================

.. py:module:: dacapo.apply


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   dacapo.apply.apply
   dacapo.apply.apply_run



Attributes
~~~~~~~~~~

.. autoapisummary::

   dacapo.apply.logger


.. py:data:: logger

   

.. py:function:: apply(run_name: str, input_container: upath.UPath | str, input_dataset: str, output_path: upath.UPath | str, validation_dataset: Optional[dacapo.experiments.datasplits.datasets.dataset.Dataset | str] = None, criterion: str = 'voi', iteration: Optional[int] = None, parameters: Optional[dacapo.experiments.tasks.post_processors.post_processor_parameters.PostProcessorParameters | str] = None, roi: Optional[funlib.geometry.Roi | str] = None, num_workers: int = 12, output_dtype: numpy.dtype | str = np.uint8, overwrite: bool = True, file_format: str = 'zarr')

   Load weights and apply a trained model to a dataset. If iteration is None, the best iteration based on the criterion is used. If roi is None, the whole input dataset is used.

   :param run_name: Name of the run to apply.
   :type run_name: str
   :param input_container: Path to the input container.
   :type input_container: Path | str
   :param input_dataset: Name of the input dataset.
   :type input_dataset: str
   :param output_path: Path to the output container.
   :type output_path: Path | str
   :param validation_dataset: Validation dataset to use for finding the best parameters. Defaults to None.
   :type validation_dataset: Optional[Dataset | str], optional
   :param criterion: Criterion to use for finding the best parameters. Defaults to "voi".
   :type criterion: str, optional
   :param iteration: Iteration to use. If None, the best iteration is used. Defaults to None.
   :type iteration: Optional[int], optional
   :param parameters: Post-processor parameters to use. If None, the best parameters are found. Defaults to None.
   :type parameters: Optional[PostProcessorParameters | str], optional
   :param roi: Region of interest to use. If None, the whole input dataset is used. Defaults to None.
   :type roi: Optional[Roi | str], optional
   :param num_workers: Number of workers to use. Defaults to 12.
   :type num_workers: int, optional
   :param output_dtype: Output dtype. Defaults to np.uint8.
   :type output_dtype: np.dtype | str, optional
   :param overwrite: Overwrite existing output. Defaults to True.
   :type overwrite: bool, optional
   :param file_format: File format to use. Defaults to "zarr".
   :type file_format: str, optional

   :raises ValueError: If validation_dataset is None and criterion is not None.
   :raises ValueError: If parameters is a string that cannot be parsed to PostProcessorParameters.
   :raises ValueError: If parameters is not a PostProcessorParameters object.

   .. rubric:: Examples

   >>> apply(
   ...     run_name="run_1",
   ...     input_container="data.zarr",
   ...     input_dataset="raw",
   ...     output_path="output.zarr",
   ...     validation_dataset="validate",
   ...     criterion="voi",
   ...     num_workers=12,
   ...     output_dtype=np.uint8,
   ...     overwrite=True,
   ... )


.. py:function:: apply_run(run: dacapo.experiments.run.Run, iteration: int, parameters: dacapo.experiments.tasks.post_processors.post_processor_parameters.PostProcessorParameters, input_array_identifier: dacapo.store.array_store.LocalArrayIdentifier, prediction_array_identifier: dacapo.store.array_store.LocalArrayIdentifier, output_array_identifier: dacapo.store.array_store.LocalArrayIdentifier, roi: Optional[funlib.geometry.Roi] = None, num_workers: int = 12, output_dtype: numpy.dtype | str = np.uint8, overwrite: bool = True)

   Apply the model to a dataset. If roi is None, the whole input dataset is used. Assumes model is already loaded.

   :param run: The run object containing the task and post-processor.
   :type run: Run
   :param iteration: The iteration number.
   :type iteration: int
   :param parameters: The post-processor parameters.
   :type parameters: PostProcessorParameters
   :param input_array_identifier: The identifier for the input array.
   :type input_array_identifier: LocalArrayIdentifier
   :param prediction_array_identifier: The identifier for the prediction array.
   :type prediction_array_identifier: LocalArrayIdentifier
   :param output_array_identifier: The identifier for the output array.
   :type output_array_identifier: LocalArrayIdentifier
   :param roi: The region of interest. Defaults to None.
   :type roi: Optional[Roi], optional
   :param num_workers: The number of workers for parallel processing. Defaults to 12.
   :type num_workers: int, optional
   :param output_dtype: The output data type. Defaults to np.uint8.
   :type output_dtype: np.dtype | str, optional
   :param overwrite: Whether to overwrite existing output. Defaults to True.
   :type overwrite: bool, optional

   :raises ValueError: If the input array is not a ZarrArray.

   .. rubric:: Examples

   >>> apply_run(
   ...     run=run,
   ...     iteration=1,
   ...     parameters=parameters,
   ...     input_array_identifier=LocalArrayIdentifier(Path("data.zarr"), "raw"),
   ...     prediction_array_identifier=LocalArrayIdentifier(Path("output.zarr"), "prediction_run_1_1"),
   ...     output_array_identifier=LocalArrayIdentifier(Path("output.zarr"), "output_run_1_1"),
   ...     roi=None,
   ...     num_workers=12,
   ...     output_dtype=np.uint8,
   ...     overwrite=True,
   ... )


