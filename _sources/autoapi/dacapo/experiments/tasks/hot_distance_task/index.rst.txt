dacapo.experiments.tasks.hot_distance_task
==========================================

.. py:module:: dacapo.experiments.tasks.hot_distance_task


Classes
-------

.. autoapisummary::

   dacapo.experiments.tasks.hot_distance_task.BinarySegmentationEvaluator
   dacapo.experiments.tasks.hot_distance_task.HotDistanceLoss
   dacapo.experiments.tasks.hot_distance_task.ThresholdPostProcessor
   dacapo.experiments.tasks.hot_distance_task.HotDistancePredictor
   dacapo.experiments.tasks.hot_distance_task.Task
   dacapo.experiments.tasks.hot_distance_task.HotDistanceTask


Module Contents
---------------

.. py:class:: BinarySegmentationEvaluator(clip_distance: float, tol_distance: float, channels: List[str])



   Given a binary segmentation, compute various metrics to determine their similarity. The metrics include:
   - Dice coefficient: 2 * |A ∩ B| / |A| + |B| ; where A and B are the binary segmentations
   - Jaccard coefficient: |A ∩ B| / |A ∪ B| ; where A and B are the binary segmentations
   - Hausdorff distance: max(h(A, B), h(B, A)) ; where h(A, B) is the Hausdorff distance between A and B
   - False negative rate: |A - B| / |A| ; where A and B are the binary segmentations
   - False positive rate: |B - A| / |B| ; where A and B are the binary segmentations
   - False discovery rate: |B - A| / |A| ; where A and B are the binary segmentations
   - VOI: Variation of Information; split and merge errors combined into a single measure of segmentation quality
   - Mean false distance: 0.5 * (mean false positive distance + mean false negative distance)
   - Mean false negative distance: mean distance of false negatives
   - Mean false positive distance: mean distance of false positives
   - Mean false distance clipped: 0.5 * (mean false positive distance clipped + mean false negative distance clipped) ; clipped to a maximum distance
   - Mean false negative distance clipped: mean distance of false negatives clipped ; clipped to a maximum distance
   - Mean false positive distance clipped: mean distance of false positives clipped ; clipped to a maximum distance
   - Precision with tolerance: TP / (TP + FP) ; where TP and FP are the true and false positives within a tolerance distance
   - Recall with tolerance: TP / (TP + FN) ; where TP and FN are the true and false positives within a tolerance distance
   - F1 score with tolerance: 2 * (Recall * Precision) / (Recall + Precision) ; where Recall and Precision are the true and false positives within a tolerance distance
   - Precision: TP / (TP + FP) ; where TP and FP are the true and false positives
   - Recall: TP / (TP + FN) ; where TP and FN are the true and false positives
   - F1 score: 2 * (Recall * Precision) / (Recall + Precision) ; where Recall and Precision are the true and false positives

   .. attribute:: clip_distance

      float
      the clip distance

   .. attribute:: tol_distance

      float
      the tolerance distance

   .. attribute:: channels

      List[str]
      the channels

   .. attribute:: criteria

      List[str]
      the evaluation criteria

   .. method:: evaluate(output_array_identifier, evaluation_array)

      
      Evaluate the output array against the evaluation array.

   .. method:: score

      
      Return the evaluation scores.

   .. note::

      The BinarySegmentationEvaluator class is used to evaluate the performance of a binary segmentation task.
      The class provides methods to evaluate the output array against the evaluation array and return the evaluation scores.
      All evaluation scores should inherit from this class.
      
      Clip distance is the maximum distance between the ground truth and the predicted segmentation for a pixel to be considered a false positive.
      Tolerance distance is the maximum distance between the ground truth and the predicted segmentation for a pixel to be considered a true positive.
      Channels are the channels of the binary segmentation.
      Criteria are the evaluation criteria.


   .. py:attribute:: criteria
      :value: ['jaccard', 'voi']



   .. py:method:: evaluate(output_array_identifier, evaluation_array)

      Evaluate the output array against the evaluation array.

      :param output_array_identifier: str
                                      the identifier of the output array
      :param evaluation_array: ZarrArray
                               the evaluation array

      :returns:

                BinarySegmentationEvaluationScores or MultiChannelBinarySegmentationEvaluationScores
                    the evaluation scores

      :raises ValueError: if the output array identifier is not valid

      .. rubric:: Examples

      >>> binary_segmentation_evaluator = BinarySegmentationEvaluator(clip_distance=200, tol_distance=40, channels=["channel1", "channel2"])
      >>> output_array_identifier = "output_array"
      >>> evaluation_array = ZarrArray.open_from_array_identifier("evaluation_array")
      >>> binary_segmentation_evaluator.evaluate(output_array_identifier, evaluation_array)
      BinarySegmentationEvaluationScores(dice=0.0, jaccard=0.0, hausdorff=0.0, false_negative_rate=0.0, false_positive_rate=0.0, false_discovery_rate=0.0, voi=0.0, mean_false_distance=0.0, mean_false_negative_distance=0.0, mean_false_positive_distance=0.0, mean_false_distance_clipped=0.0, mean_false_negative_distance_clipped=0.0, mean_false_positive_distance_clipped=0.0, precision_with_tolerance=0.0, recall_with_tolerance=0.0, f1_score_with_tolerance=0.0, precision=0.0, recall=0.0, f1_score=0.0)

      .. note:: This function is used to evaluate the output array against the evaluation array.



   .. py:property:: score
      Return the evaluation scores.

      :returns:

                BinarySegmentationEvaluationScores or MultiChannelBinarySegmentationEvaluationScores
                    the evaluation scores

      :raises NotImplementedError: if the function is not implemented

      .. rubric:: Examples

      >>> binary_segmentation_evaluator = BinarySegmentationEvaluator(clip_distance=200, tol_distance=40, channels=["channel1", "channel2"])
      >>> binary_segmentation_evaluator.score
      BinarySegmentationEvaluationScores(dice=0.0, jaccard=0.0, hausdorff=0.0, false_negative_rate=0.0, false_positive_rate=0.0, false_discovery_rate=0.0, voi=0.0, mean_false_distance=0.0, mean_false_negative_distance=0.0, mean_false_positive_distance=0.0, mean_false_distance_clipped=0.0, mean_false_negative_distance_clipped=0.0, mean_false_positive_distance_clipped=0.0, precision_with_tolerance=0.0, recall_with_tolerance=0.0, f1_score_with_tolerance=0.0, precision=0.0, recall=0.0, f1_score=0.0)

      .. note:: This function is used to return the evaluation scores.


.. py:class:: HotDistanceLoss



   A class used to represent the Hot Distance Loss function. This class inherits from the Loss class. The Hot Distance Loss
   function is used for predicting hot and distance maps at the same time. The first half of the channels are the hot maps,
   the second half are the distance maps. The loss is the sum of the BCELoss for the hot maps and the MSELoss for the distance
   maps. The model should predict twice the number of channels as the target.

   .. attribute:: hot_loss

      The Binary Cross Entropy Loss function.

   .. attribute:: distance_loss

      The Mean Square Error Loss function.

   .. method:: compute(prediction, target, weight) -> torch.Tensor

      
      Function to compute the Hot Distance Loss for the provided prediction and target, with respect to the weight.

   .. method:: split(x) -> Tuple[torch.Tensor, torch.Tensor]

      
      Function to split the input tensor into two tensors.

   .. note::

      This class is abstract. Subclasses must implement the abstract methods. Once created, the values of its attributes
      cannot be changed.


   .. py:method:: compute(prediction, target, weight)

      Function to compute the Hot Distance Loss for the provided prediction and target, with respect to the weight.

      :param prediction: torch.Tensor
                         The predicted tensor.
      :param target: torch.Tensor
                     The target tensor.
      :param weight: torch.Tensor
                     The weight tensor.

      :returns:

                torch.Tensor
                    The computed Hot Distance Loss tensor.

      :raises NotImplementedError: If the method is not implemented in the subclass.

      .. rubric:: Examples

      >>> loss = HotDistanceLoss()
      >>> prediction = torch.tensor([1.0, 2.0, 3.0])
      >>> target = torch.tensor([1.0, 2.0, 3.0])
      >>> weight = torch.tensor([1.0, 1.0, 1.0])
      >>> loss.compute(prediction, target, weight)
      tensor(0.)

      .. note:: This method must be implemented in the subclass. It should return the computed Hot Distance Loss tensor.



   .. py:method:: hot_loss(prediction, target, weight)

      The Binary Cross Entropy Loss function. This function computes the BCELoss for the hot maps.

      :param prediction: torch.Tensor
                         The predicted tensor.
      :param target: torch.Tensor
                     The target tensor.
      :param weight: torch.Tensor
                     The weight tensor.

      :returns:

                torch.Tensor
                    The computed BCELoss tensor.

      :raises NotImplementedError: If the method is not implemented in the subclass.

      .. rubric:: Examples

      >>> loss = HotDistanceLoss()
      >>> prediction = torch.tensor([1.0, 2.0, 3.0])
      >>> target = torch.tensor([1.0, 2.0, 3.0])
      >>> weight = torch.tensor([1.0, 1.0, 1.0])
      >>> loss.hot_loss(prediction, target, weight)
      tensor(0.)

      .. note:: This method must be implemented in the subclass. It should return the computed BCELoss tensor.



   .. py:method:: distance_loss(prediction, target, weight)

      The Mean Square Error Loss function. This function computes the MSELoss for the distance maps.

      :param prediction: torch.Tensor
                         The predicted tensor.
      :param target: torch.Tensor
                     The target tensor.
      :param weight: torch.Tensor
                     The weight tensor.

      :returns:

                torch.Tensor
                    The computed MSELoss tensor.

      :raises NotImplementedError: If the method is not implemented in the subclass.

      .. rubric:: Examples

      >>> loss = HotDistanceLoss()
      >>> prediction = torch.tensor([1.0, 2.0, 3.0])
      >>> target = torch.tensor([1.0, 2.0, 3.0])
      >>> weight = torch.tensor([1.0, 1.0, 1.0])
      >>> loss.distance_loss(prediction, target, weight)
      tensor(0.)

      .. note:: This method must be implemented in the subclass. It should return the computed MSELoss tensor.



   .. py:method:: split(x)

      Function to split the input tensor into two tensors.

      :param x: torch.Tensor
                The input tensor.

      :returns:

                Tuple[torch.Tensor, torch.Tensor]
                    The two split tensors.

      :raises NotImplementedError: If the method is not implemented in the subclass.

      .. rubric:: Examples

      >>> loss = HotDistanceLoss()
      >>> x = torch.tensor([1.0, 2.0, 3.0])
      >>> loss.split(x)
      (tensor([1.0]), tensor([2.0]))

      .. note:: This method must be implemented in the subclass. It should return the two split tensors.



.. py:class:: ThresholdPostProcessor



   A post-processor that applies a threshold to the prediction.

   .. attribute:: prediction_array_identifier

      The identifier of the prediction array.

   .. attribute:: prediction_array

      The prediction array.

   .. method:: enumerate_parameters

      Enumerate all possible parameters of this post-processor.

   .. method:: set_prediction

      Set the prediction array.

   .. method:: process

      Process the prediction with the given parameters.

   .. note:: This post-processor applies a threshold to the prediction. The threshold is used to define the segmentation. The prediction array is set using the `set_prediction` method.


   .. py:method:: enumerate_parameters() -> Iterable[dacapo.experiments.tasks.post_processors.threshold_post_processor_parameters.ThresholdPostProcessorParameters]

      Enumerate all possible parameters of this post-processor.

      :returns: A generator of parameters.
      :rtype: Generator[ThresholdPostProcessorParameters]

      :raises NotImplementedError: If the method is not implemented.

      .. rubric:: Examples

      >>> for parameters in post_processor.enumerate_parameters():
      ...     print(parameters)

      .. note:: This method should return a generator of instances of ``ThresholdPostProcessorParameters``.



   .. py:method:: set_prediction(prediction_array_identifier)

      Set the prediction array.

      :param prediction_array_identifier: The identifier of the prediction array.
      :type prediction_array_identifier: LocalArrayIdentifier

      :raises NotImplementedError: If the method is not implemented.

      .. rubric:: Examples

      >>> post_processor.set_prediction(prediction_array_identifier)

      .. note:: This method should set the prediction array using the given identifier.



   .. py:method:: process(parameters: dacapo.experiments.tasks.post_processors.threshold_post_processor_parameters.ThresholdPostProcessorParameters, output_array_identifier: dacapo.store.array_store.LocalArrayIdentifier, num_workers: int = 16, block_size: daisy.Coordinate = Coordinate((256, 256, 256))) -> dacapo.experiments.datasplits.datasets.arrays.zarr_array.ZarrArray

      Process the prediction with the given parameters.

      :param parameters: The parameters to use for processing.
      :type parameters: ThresholdPostProcessorParameters
      :param output_array_identifier: The identifier of the output array.
      :type output_array_identifier: LocalArrayIdentifier
      :param num_workers: The number of workers to use for processing.
      :type num_workers: int
      :param block_size: The block size to use for processing.
      :type block_size: Coordinate

      :returns: The output array.
      :rtype: ZarrArray

      :raises NotImplementedError: If the method is not implemented.

      .. rubric:: Examples

      >>> post_processor.process(parameters, output_array_identifier)

      .. note::

         This method should process the prediction with the given parameters and return the output array. The method uses the `run_blockwise` function from the `dacapo.blockwise.scheduler` module to run the blockwise post-processing.
         The output array is created using the `ZarrArray.create_from_array_identifier` function from the `dacapo.experiments.datasplits.datasets.arrays` module.



.. py:class:: HotDistancePredictor(channels: List[str], scale_factor: float, mask_distances: bool)



   Predict signed distances and one hot embedding (as a proxy task) for a binary segmentation task.
   Distances deep within background are pushed to -inf, distances deep within
   the foreground object are pushed to inf. After distances have been
   calculated they are passed through a tanh so that distances saturate at +-1.
   Multiple classes can be predicted via multiple distance channels. The names
   of each class that is being segmented can be passed in as a list of strings
   in the channels argument.

   .. attribute:: channels

      List of strings, each string is the name of a class that is being segmented.

   .. attribute:: scale_factor

      The scale factor for the distance transform.

   .. attribute:: mask_distances

      Whether to mask distances based on the distance to the boundary.

   .. attribute:: norm

      The normalization function to use for the distance transform.

   .. attribute:: dt_scale_factor

      The scale factor for the distance transform.

   .. attribute:: max_distance

      The maximum distance to consider for the distance transform.

   .. attribute:: epsilon

      The epsilon value to use for the distance transform.

   .. attribute:: threshold

      The threshold value to use for the distance transform.

   .. method:: __init__(self, channels

      List[str], scale_factor: float, mask_distances: bool): Initializes the HotDistancePredictor.

   .. method:: create_model(self, architecture)

      Create the model for the predictor.

   .. method:: create_target(self, gt)

      Create the target array for training.

   .. method:: create_weight(self, gt, target, mask, moving_class_counts=None)

      Create the weight array for training.

   .. method:: create_distance_mask(self, distances, mask, voxel_size, normalize=None, normalize_args=None)

      Create the distance mask for training.

   .. method:: process(self, labels, voxel_size, normalize=None, normalize_args=None)

      Process the labels array and convert it to one-hot encoding.

   .. method:: gt_region_for_roi(self, target_spec)

      Report how much spatial context this predictor needs to generate a target for the given ROI.

   .. method:: padding(self, gt_voxel_size)

      Return the padding needed for the ground-truth

   .. rubric:: Notes

   This is a subclass of Predictor.


   .. py:property:: embedding_dims
      Get the number of embedding dimensions.

      :returns: The number of embedding dimensions.
      :rtype: int

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> embedding_dims = predictor.embedding_dims


   .. py:property:: classes
      Get the number of classes.

      :returns: The number of classes.
      :rtype: int

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> classes = predictor.classes


   .. py:method:: create_model(architecture)

      Create the model for the predictor.

      :param architecture: The architecture for the model.

      :returns: The created model.
      :rtype: Model

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> model = predictor.create_model(architecture)



   .. py:method:: create_target(gt)

      Create the target array for training.

      :param gt: The ground truth array.

      :returns: The created target array.
      :rtype: NumpyArray

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> target = predictor.create_target(gt)



   .. py:method:: create_weight(gt, target, mask, moving_class_counts=None)

      Create the weight array for training, given a ground-truth and
      associated target array.

      :param gt: The ground-truth array.
      :param target: The target array.
      :param mask: The mask array.
      :param moving_class_counts: The moving class counts.

      :returns: The weight array and the moving class counts.
      :rtype: Tuple[NumpyArray, np.ndarray]

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> predictor.create_weight(gt, target, mask, moving_class_counts)



   .. py:property:: output_array_type
      Get the output array type.

      :returns: The output array type.
      :rtype: ProbabilityArray

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> output_array_type = predictor.output_array_type

      .. rubric:: Notes

      Technically this is a probability array + distance array, but it is only ever referenced for interpolatability (which is true for both).


   .. py:method:: create_distance_mask(distances: numpy.ndarray, mask: numpy.ndarray, voxel_size: funlib.geometry.Coordinate, normalize=None, normalize_args=None)

      Create the distance mask for training.

      :param distances: The distances array.
      :param mask: The mask array.
      :param voxel_size: The voxel size.
      :param normalize: The normalization function to use.
      :param normalize_args: The normalization arguments.

      :returns: The distance mask.
      :rtype: np.ndarray

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> distance_mask = self.create_distance_mask(distances, mask, voxel_size, normalize, normalize_args)



   .. py:method:: process(labels: numpy.ndarray, voxel_size: funlib.geometry.Coordinate, normalize=None, normalize_args=None)

      Process the labels array and convert it to one-hot encoding.

      :param labels: The labels array.
      :param voxel_size: The voxel size.
      :param normalize: The normalization function to use.
      :param normalize_args: The normalization arguments.

      :returns: The one-hot encoded array.
      :rtype: np.ndarray

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> predictor.process(labels, voxel_size, normalize, normalize_args)



   .. py:method:: gt_region_for_roi(target_spec)

      Report how much spatial context this predictor needs to generate a
      target for the given ROI. By default, uses the same ROI.

      :param target_spec: The ROI for which the target is requested.

      :returns: The ROI for which the ground-truth is requested.

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> predictor.gt_region_for_roi(target_spec)



   .. py:method:: padding(gt_voxel_size: funlib.geometry.Coordinate) -> funlib.geometry.Coordinate

      Return the padding needed for the ground-truth array.

      :param gt_voxel_size: The voxel size of the ground-truth array.

      :returns: The padding needed for the ground-truth array.
      :rtype: Coordinate

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> predictor.padding(gt_voxel_size)



.. py:class:: Task



   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: predictor
      :type:  dacapo.experiments.tasks.predictors.Predictor


   .. py:attribute:: loss
      :type:  dacapo.experiments.tasks.losses.Loss


   .. py:attribute:: evaluator
      :type:  dacapo.experiments.tasks.evaluators.Evaluator


   .. py:attribute:: post_processor
      :type:  dacapo.experiments.tasks.post_processors.PostProcessor


   .. py:property:: parameters
      :type: Iterable[dacapo.experiments.tasks.post_processors.PostProcessorParameters]



   .. py:property:: evaluation_scores
      :type: dacapo.experiments.tasks.evaluators.EvaluationScores



   .. py:method:: create_model(architecture)


.. py:class:: HotDistanceTask(task_config)



   A class to represent a hot distance task that use binary prediction and distance prediction.

   Inherits from Task class.

   .. attribute:: predictor

      HotDistancePredictor object.

   .. attribute:: loss

      HotDistanceLoss object.

   .. attribute:: post_processor

      ThresholdPostProcessor object.

   .. attribute:: evaluator

      BinarySegmentationEvaluator object.

   .. method:: __init__(self, task_config)

      Constructs all the necessary attributes for the HotDistanceTask object.

   .. rubric:: Notes

   This is a subclass of Task.


