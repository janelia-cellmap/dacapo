dacapo.experiments.tasks.distance_task
======================================

.. py:module:: dacapo.experiments.tasks.distance_task


Classes
-------

.. autoapisummary::

   dacapo.experiments.tasks.distance_task.BinarySegmentationEvaluator
   dacapo.experiments.tasks.distance_task.MSELoss
   dacapo.experiments.tasks.distance_task.ThresholdPostProcessor
   dacapo.experiments.tasks.distance_task.DistancePredictor
   dacapo.experiments.tasks.distance_task.Task
   dacapo.experiments.tasks.distance_task.DistanceTask


Module Contents
---------------

.. py:class:: BinarySegmentationEvaluator(clip_distance: float, tol_distance: float, channels: List[str])



   Given a binary segmentation, compute various metrics to determine their similarity. The metrics include:
   - Dice coefficient: 2 * |A ∩ B| / |A| + |B| ; where A and B are the binary segmentations
   - Jaccard coefficient: |A ∩ B| / |A ∪ B| ; where A and B are the binary segmentations
   - Hausdorff distance: max(h(A, B), h(B, A)) ; where h(A, B) is the Hausdorff distance between A and B
   - False negative rate: |A - B| / |A| ; where A and B are the binary segmentations
   - False positive rate: |B - A| / |B| ; where A and B are the binary segmentations
   - False discovery rate: |B - A| / |A| ; where A and B are the binary segmentations
   - VOI: Variation of Information; split and merge errors combined into a single measure of segmentation quality
   - Mean false distance: 0.5 * (mean false positive distance + mean false negative distance)
   - Mean false negative distance: mean distance of false negatives
   - Mean false positive distance: mean distance of false positives
   - Mean false distance clipped: 0.5 * (mean false positive distance clipped + mean false negative distance clipped) ; clipped to a maximum distance
   - Mean false negative distance clipped: mean distance of false negatives clipped ; clipped to a maximum distance
   - Mean false positive distance clipped: mean distance of false positives clipped ; clipped to a maximum distance
   - Precision with tolerance: TP / (TP + FP) ; where TP and FP are the true and false positives within a tolerance distance
   - Recall with tolerance: TP / (TP + FN) ; where TP and FN are the true and false positives within a tolerance distance
   - F1 score with tolerance: 2 * (Recall * Precision) / (Recall + Precision) ; where Recall and Precision are the true and false positives within a tolerance distance
   - Precision: TP / (TP + FP) ; where TP and FP are the true and false positives
   - Recall: TP / (TP + FN) ; where TP and FN are the true and false positives
   - F1 score: 2 * (Recall * Precision) / (Recall + Precision) ; where Recall and Precision are the true and false positives

   .. attribute:: clip_distance

      float
      the clip distance

   .. attribute:: tol_distance

      float
      the tolerance distance

   .. attribute:: channels

      List[str]
      the channels

   .. attribute:: criteria

      List[str]
      the evaluation criteria

   .. method:: evaluate(output_array_identifier, evaluation_array)

      
      Evaluate the output array against the evaluation array.

   .. method:: score

      
      Return the evaluation scores.

   .. note::

      The BinarySegmentationEvaluator class is used to evaluate the performance of a binary segmentation task.
      The class provides methods to evaluate the output array against the evaluation array and return the evaluation scores.
      All evaluation scores should inherit from this class.
      
      Clip distance is the maximum distance between the ground truth and the predicted segmentation for a pixel to be considered a false positive.
      Tolerance distance is the maximum distance between the ground truth and the predicted segmentation for a pixel to be considered a true positive.
      Channels are the channels of the binary segmentation.
      Criteria are the evaluation criteria.


   .. py:attribute:: criteria
      :value: ['jaccard', 'voi']



   .. py:method:: evaluate(output_array_identifier, evaluation_array)

      Evaluate the output array against the evaluation array.

      :param output_array_identifier: str
                                      the identifier of the output array
      :param evaluation_array: ZarrArray
                               the evaluation array

      :returns:

                BinarySegmentationEvaluationScores or MultiChannelBinarySegmentationEvaluationScores
                    the evaluation scores

      :raises ValueError: if the output array identifier is not valid

      .. rubric:: Examples

      >>> binary_segmentation_evaluator = BinarySegmentationEvaluator(clip_distance=200, tol_distance=40, channels=["channel1", "channel2"])
      >>> output_array_identifier = "output_array"
      >>> evaluation_array = ZarrArray.open_from_array_identifier("evaluation_array")
      >>> binary_segmentation_evaluator.evaluate(output_array_identifier, evaluation_array)
      BinarySegmentationEvaluationScores(dice=0.0, jaccard=0.0, hausdorff=0.0, false_negative_rate=0.0, false_positive_rate=0.0, false_discovery_rate=0.0, voi=0.0, mean_false_distance=0.0, mean_false_negative_distance=0.0, mean_false_positive_distance=0.0, mean_false_distance_clipped=0.0, mean_false_negative_distance_clipped=0.0, mean_false_positive_distance_clipped=0.0, precision_with_tolerance=0.0, recall_with_tolerance=0.0, f1_score_with_tolerance=0.0, precision=0.0, recall=0.0, f1_score=0.0)

      .. note:: This function is used to evaluate the output array against the evaluation array.



   .. py:property:: score
      Return the evaluation scores.

      :returns:

                BinarySegmentationEvaluationScores or MultiChannelBinarySegmentationEvaluationScores
                    the evaluation scores

      :raises NotImplementedError: if the function is not implemented

      .. rubric:: Examples

      >>> binary_segmentation_evaluator = BinarySegmentationEvaluator(clip_distance=200, tol_distance=40, channels=["channel1", "channel2"])
      >>> binary_segmentation_evaluator.score
      BinarySegmentationEvaluationScores(dice=0.0, jaccard=0.0, hausdorff=0.0, false_negative_rate=0.0, false_positive_rate=0.0, false_discovery_rate=0.0, voi=0.0, mean_false_distance=0.0, mean_false_negative_distance=0.0, mean_false_positive_distance=0.0, mean_false_distance_clipped=0.0, mean_false_negative_distance_clipped=0.0, mean_false_positive_distance_clipped=0.0, precision_with_tolerance=0.0, recall_with_tolerance=0.0, f1_score_with_tolerance=0.0, precision=0.0, recall=0.0, f1_score=0.0)

      .. note:: This function is used to return the evaluation scores.


.. py:class:: MSELoss



   A class used to represent the Mean Square Error Loss function (MSELoss). This class inherits from the Loss class.

   .. method:: compute(prediction, target, weight) -> torch.Tensor

      
      Function to compute the MSELoss for the provided prediction and target, with respect to the weight.

   .. note::

      This class is abstract. Subclasses must implement the abstract methods. Once created, the values of its attributes
      cannot be changed.


   .. py:method:: compute(prediction, target, weight)

      Function to compute the MSELoss for the provided prediction and target, with respect to the weight.

      :param prediction: torch.Tensor
                         The predicted tensor.
      :param target: torch.Tensor
                     The target tensor.
      :param weight: torch.Tensor
                     The weight tensor.

      :returns:

                torch.Tensor
                    The computed MSELoss tensor.

      :raises NotImplementedError: If the method is not implemented in the subclass.

      .. rubric:: Examples

      >>> loss = MSELoss()
      >>> prediction = torch.tensor([1.0, 2.0, 3.0])
      >>> target = torch.tensor([1.0, 2.0, 3.0])
      >>> weight = torch.tensor([1.0, 1.0, 1.0])
      >>> loss.compute(prediction, target, weight)
      tensor(0.)

      .. note:: This method must be implemented in the subclass. It should return the computed MSELoss tensor.



.. py:class:: ThresholdPostProcessor



   A post-processor that applies a threshold to the prediction.

   .. attribute:: prediction_array_identifier

      The identifier of the prediction array.

   .. attribute:: prediction_array

      The prediction array.

   .. method:: enumerate_parameters

      Enumerate all possible parameters of this post-processor.

   .. method:: set_prediction

      Set the prediction array.

   .. method:: process

      Process the prediction with the given parameters.

   .. note:: This post-processor applies a threshold to the prediction. The threshold is used to define the segmentation. The prediction array is set using the `set_prediction` method.


   .. py:method:: enumerate_parameters() -> Iterable[dacapo.experiments.tasks.post_processors.threshold_post_processor_parameters.ThresholdPostProcessorParameters]

      Enumerate all possible parameters of this post-processor.

      :returns: A generator of parameters.
      :rtype: Generator[ThresholdPostProcessorParameters]

      :raises NotImplementedError: If the method is not implemented.

      .. rubric:: Examples

      >>> for parameters in post_processor.enumerate_parameters():
      ...     print(parameters)

      .. note:: This method should return a generator of instances of ``ThresholdPostProcessorParameters``.



   .. py:method:: set_prediction(prediction_array_identifier)

      Set the prediction array.

      :param prediction_array_identifier: The identifier of the prediction array.
      :type prediction_array_identifier: LocalArrayIdentifier

      :raises NotImplementedError: If the method is not implemented.

      .. rubric:: Examples

      >>> post_processor.set_prediction(prediction_array_identifier)

      .. note:: This method should set the prediction array using the given identifier.



   .. py:method:: process(parameters: dacapo.experiments.tasks.post_processors.threshold_post_processor_parameters.ThresholdPostProcessorParameters, output_array_identifier: dacapo.store.array_store.LocalArrayIdentifier, num_workers: int = 16, block_size: daisy.Coordinate = Coordinate((256, 256, 256))) -> dacapo.experiments.datasplits.datasets.arrays.zarr_array.ZarrArray

      Process the prediction with the given parameters.

      :param parameters: The parameters to use for processing.
      :type parameters: ThresholdPostProcessorParameters
      :param output_array_identifier: The identifier of the output array.
      :type output_array_identifier: LocalArrayIdentifier
      :param num_workers: The number of workers to use for processing.
      :type num_workers: int
      :param block_size: The block size to use for processing.
      :type block_size: Coordinate

      :returns: The output array.
      :rtype: ZarrArray

      :raises NotImplementedError: If the method is not implemented.

      .. rubric:: Examples

      >>> post_processor.process(parameters, output_array_identifier)

      .. note::

         This method should process the prediction with the given parameters and return the output array. The method uses the `run_blockwise` function from the `dacapo.blockwise.scheduler` module to run the blockwise post-processing.
         The output array is created using the `ZarrArray.create_from_array_identifier` function from the `dacapo.experiments.datasplits.datasets.arrays` module.



.. py:class:: DistancePredictor(channels: List[str], scale_factor: float, mask_distances: bool, clipmin: float = 0.05, clipmax: float = 0.95)



   Predict signed distances for a binary segmentation task.
   Distances deep within background are pushed to -inf, distances deep within
   the foreground object are pushed to inf. After distances have been
   calculated they are passed through a tanh so that distances saturate at +-1.
   Multiple classes can be predicted via multiple distance channels. The names
   of each class that is being segmented can be passed in as a list of strings
   in the channels argument.

   .. attribute:: channels

      The list of class labels.

      :type: List[str]

   .. attribute:: scale_factor

      The scale factor for the distance transform.

      :type: float

   .. attribute:: mask_distances

      Whether to mask distances.

      :type: bool

   .. attribute:: clipmin

      The minimum value to clip the weights to.

      :type: float

   .. attribute:: clipmax

      The maximum value to clip the weights to.

      :type: float

   .. method:: __init__(self, channels

      List[str], scale_factor: float, mask_distances: bool, clipmin: float = 0.05, clipmax: float = 0.95): Initializes the DistancePredictor.

   .. method:: create_model(self, architecture)

      Create the model for the predictor.

   .. method:: create_target(self, gt)

      Create the target array for training.

   .. method:: create_weight(self, gt, target, mask, moving_class_counts=None)

      Create the weight array for training.

   .. method:: output_array_type

      Get the output array type.

   .. method:: create_distance_mask(self, distances, mask, voxel_size, normalize=None, normalize_args=None)

      Create the distance mask.

   .. method:: process(self, labels, voxel_size, normalize=None, normalize_args=None)

      Process the labels array.

   .. method:: gt_region_for_roi(self, target_spec)

      Get the ground-truth region for the ROI.

   .. method:: padding(self, gt_voxel_size

      Coordinate) -> Coordinate: Get the padding needed for the ground-truth array.

   .. rubric:: Notes

   The DistancePredictor is used to predict signed distances for a binary segmentation task.
   The distances are calculated using the distance_transform_edt function from scipy.ndimage.morphology.
   The distances are then passed through a tanh function to saturate the distances at +-1.
   The distances are calculated for each class that is being segmented and are stored in separate channels.
   The names of each class that is being segmented can be passed in as a list of strings in the channels argument.
   The scale_factor argument is used to scale the distances.
   The mask_distances argument is used to determine whether to mask distances.
   The clipmin argument is used to determine the minimum value to clip the weights to.
   The clipmax argument is used to determine the maximum value to clip the weights to.


   .. py:property:: embedding_dims
      Get the number of embedding dimensions.

      :returns: The number of embedding dimensions.
      :rtype: int

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> embedding_dims = predictor.embedding_dims


   .. py:method:: create_model(architecture)

      Create the model for the predictor.

      :param architecture: The architecture for the model.

      :returns: The created model.
      :rtype: Model

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> model = predictor.create_model(architecture)



   .. py:method:: create_target(gt)

      Create the target array for training.

      :param gt: The ground-truth array.

      :returns: The created target array.
      :rtype: NumpyArray

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> predictor.create_target(gt)



   .. py:method:: create_weight(gt, target, mask, moving_class_counts=None)

      Create the weight array for training, given a ground-truth and
      associated target array.

      :param gt: The ground-truth array.
      :param target: The target array.
      :param mask: The mask array.
      :param moving_class_counts: The moving class counts.

      :returns: The weight array and the moving class counts.

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> predictor.create_weight(gt, target, mask, moving_class_counts)



   .. py:property:: output_array_type
      Get the output array type.

      :returns: The output array type.
      :rtype: DistanceArray

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> predictor.output_array_type


   .. py:method:: create_distance_mask(distances: numpy.ndarray, mask: numpy.ndarray, voxel_size: funlib.geometry.Coordinate, normalize=None, normalize_args=None)

      Create a distance mask.

      :param distances: The distances array.
      :type distances: np.ndarray
      :param mask: The mask array.
      :type mask: np.ndarray
      :param voxel_size: The voxel size.
      :type voxel_size: Coordinate
      :param normalize: The normalization method.
      :type normalize: str
      :param normalize_args: The normalization arguments.

      :returns: The distance mask.
      :rtype: np.ndarray

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> predictor.create_distance_mask(distances, mask, voxel_size, normalize, normalize_args)



   .. py:method:: process(labels: numpy.ndarray, voxel_size: funlib.geometry.Coordinate, normalize=None, normalize_args=None)

      Process the labels array and convert it to one-hot encoding.

      :param labels: The labels array.
      :type labels: np.ndarray
      :param voxel_size: The voxel size.
      :type voxel_size: Coordinate
      :param normalize: The normalization method.
      :type normalize: str
      :param normalize_args: The normalization arguments.

      :returns: The distances array.
      :rtype: np.ndarray

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> predictor.process(labels, voxel_size, normalize, normalize_args)



   .. py:method:: gt_region_for_roi(target_spec)

      Report how much spatial context this predictor needs to generate a
      target for the given ROI. By default, uses the same ROI.

      :param target_spec: The ROI for which the target is requested.

      :returns: The ROI for which the ground-truth is requested.

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> predictor.gt_region_for_roi(target_spec)



   .. py:method:: padding(gt_voxel_size: funlib.geometry.Coordinate) -> funlib.geometry.Coordinate

      Return the padding needed for the ground-truth array.

      :param gt_voxel_size: The voxel size of the ground-truth array.
      :type gt_voxel_size: Coordinate

      :returns: The padding needed for the ground-truth array.
      :rtype: Coordinate

      :raises NotImplementedError: This method is not implemented.

      .. rubric:: Examples

      >>> predictor.padding(gt_voxel_size)



.. py:class:: Task



   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: predictor
      :type:  dacapo.experiments.tasks.predictors.Predictor


   .. py:attribute:: loss
      :type:  dacapo.experiments.tasks.losses.Loss


   .. py:attribute:: evaluator
      :type:  dacapo.experiments.tasks.evaluators.Evaluator


   .. py:attribute:: post_processor
      :type:  dacapo.experiments.tasks.post_processors.PostProcessor


   .. py:property:: parameters
      :type: Iterable[dacapo.experiments.tasks.post_processors.PostProcessorParameters]



   .. py:property:: evaluation_scores
      :type: dacapo.experiments.tasks.evaluators.EvaluationScores



   .. py:method:: create_model(architecture)


.. py:class:: DistanceTask(task_config)



   DistanceTask is a subclass of Task for handling tasks associated
   with Distance.

   DistanceTask uses `DistancePredictor` for prediction, `MSELoss` for
   computing loss, `ThresholdPostProcessor` for post-processing the
   prediction, and `BinarySegmentationEvaluator` for evaluating the
   prediction.

   .. attribute:: predictor

      DistancePredictor object

   .. attribute:: loss

      MSELoss object

   .. attribute:: post_processor

      ThresholdPostProcessor object

   .. attribute:: evaluator

      BinarySegmentationEvaluator object

   .. method:: __init__(self, task_config)

      Initializes attributes of DistanceTask

   .. rubric:: Notes

   This is a subclass of Task.


